/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => ExtendedTaskListsPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian2 = require("obsidian");

// src/fileService.ts
var VaultFileService = class {
  constructor(vault) {
    this.vault = vault;
  }
  async getFiles() {
    return this.vault.getMarkdownFiles();
  }
  async readFile(file) {
    return await this.vault.cachedRead(file);
  }
  async updateFile(file, data) {
    await this.vault.modify(file, data);
  }
  async checkExists(filepath) {
    return await this.vault.adapter.exists(filepath);
  }
};

// src/settings.ts
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  todoFilename: "TODO.md",
  excludeFilePattern: "<!-- exclude TODO -->",
  excludeFolderFilename: ".exclude_todos",
  useFullFilepath: false,
  includeNotStarted: true,
  includeInProgress: true,
  includeWontDo: false,
  includeDone: false
};
var ExtendedTaskListsSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    this.containerEl.createEl("h2", { text: "Generated TODO" });
    new import_obsidian.Setting(containerEl).setName("TODO filename").addText((text) => text.setValue(this.plugin.settings.todoFilename).onChange(async (value) => {
      this.plugin.settings.todoFilename = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Exclude file pattern").setDesc("A pattern that should be inserted anywhere in a Markdown file to exclude it from the generated TODO file.").addText((text) => text.setValue(this.plugin.settings.excludeFilePattern).onChange(async (value) => {
      this.plugin.settings.excludeFilePattern = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Exclude folder filename").setDesc('The filename to add to a folder to exclude all task lists in it from the generated TODO file. You may prefer to change the default value since dot files (files that start with a ".") do not show up within Obsidian.').addText((text) => text.setValue(this.plugin.settings.excludeFolderFilename).onChange(async (value) => {
      this.plugin.settings.excludeFolderFilename = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Include not started tasks").addToggle((toggle) => toggle.setValue(this.plugin.settings.includeNotStarted).onChange(async (value) => {
      this.plugin.settings.includeNotStarted = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Use full filepath").setDesc("If checked, the full Vault filepath is used for the label of grouped task items in the generated TODO file").addToggle((toggle) => toggle.setValue(this.plugin.settings.useFullFilepath).onChange(async (value) => {
      this.plugin.settings.useFullFilepath = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Include in progress tasks").addToggle((toggle) => toggle.setValue(this.plugin.settings.includeInProgress).onChange(async (value) => {
      this.plugin.settings.includeInProgress = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Include won't do tasks").addToggle((toggle) => toggle.setValue(this.plugin.settings.includeWontDo).onChange(async (value) => {
      this.plugin.settings.includeWontDo = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Include done tasks").addToggle((toggle) => toggle.setValue(this.plugin.settings.includeDone).onChange(async (value) => {
      this.plugin.settings.includeDone = value;
      await this.plugin.saveSettings();
    }));
  }
};

// src/todoService.ts
var TODO_PATTERN = /^(?<indentation>\s*)-\s?\[(?<task>.)\]\s+(?<text>.*)$/;
var TodoService = class {
  constructor(fileService, settings) {
    this.fileService = fileService;
    this.settings = settings;
    this.excludeCache = {};
  }
  /**
   * Find all the non-excluded Markdown files that _may_ contain task items.
   */
  async findTodosFiles() {
    const markdownFiles = await this.fileService.getFiles();
    const shouldExcludeFiles = await Promise.all(markdownFiles.map(
      async (file) => await this.getShouldExcludeFile(file)
    ));
    const filteredMarkdownFiles = markdownFiles.filter((_, index) => !shouldExcludeFiles[index]);
    let todoFiles = await Promise.all(filteredMarkdownFiles.map(async (file) => {
      const contents = await this.fileService.readFile(file);
      return { file, contents };
    }));
    todoFiles = todoFiles.filter(
      (todoFile) => !todoFile.contents.split(/[\r\n]+/).some((line) => line.trim() === this.settings.excludeFilePattern)
    );
    return todoFiles;
  }
  /**
   * Parse all the task items from the string
   */
  parseTodos(contents) {
    const lines = contents.split(/[\r]?[\n]/);
    const matchesAndIndices = lines.map((line, index) => {
      const match = line.match(TODO_PATTERN);
      return { match, index };
    }).filter((indexMatch) => indexMatch.match != null);
    const todos = matchesAndIndices.map((indexMatch) => {
      var _a, _b, _c;
      const lineno = indexMatch.index;
      const task = (_a = indexMatch.match.groups) == null ? void 0 : _a.task;
      const text = (_b = indexMatch.match.groups) == null ? void 0 : _b.text;
      const indentation = (_c = indexMatch.match.groups) == null ? void 0 : _c.indentation;
      return { task, text, indentation, lineno };
    });
    const todoToPrevSibling = /* @__PURE__ */ new Map();
    todos.forEach((todo) => {
      const prevSibling = todos.find((t) => t.lineno === todo.lineno - 1) || null;
      todoToPrevSibling.set(todo, prevSibling);
    });
    const kvps = [...todoToPrevSibling];
    kvps.filter((kvp) => kvp[1] == null).forEach((kvp) => kvp[0].indentation = "");
    kvps.filter((kvp) => kvp[1] != null && kvp[0].indentation.length > kvp[1].indentation.length).forEach((kvp) => kvp[0].indentation = kvp[1].indentation + "    ");
    return todos;
  }
  /**
   * Save the task items to the TODO file
   */
  async saveTodos(todoFile, todos) {
    let data = "";
    todos.sort((a, b) => a.file.stat.ctime - b.file.stat.ctime);
    todos = todos.filter(
      (todo) => todo.task === " " /* NotStarted */ && this.settings.includeNotStarted || todo.task === "." /* InProgress */ && this.settings.includeInProgress || todo.task === "~" /* WontDo */ && this.settings.includeWontDo || todo.task === "x" /* Done */ && this.settings.includeDone
    );
    const todosByFile = /* @__PURE__ */ new Map();
    todos.forEach((todo) => {
      if (!todosByFile.get(todo.file)) {
        todosByFile.set(todo.file, []);
      }
      todosByFile.get(todo.file).push(todo);
    });
    todosByFile.forEach((todos2, file) => {
      const urlEncodedFilePath = encodeURI(file.path);
      const heading = this.settings.useFullFilepath ? `- [${file.path}](${urlEncodedFilePath})
` : `- [${file.basename}](${urlEncodedFilePath})
`;
      data += heading;
      todos2.forEach((todo) => {
        data += `	${todo.indentation}- [${todo.task}] ${todo.text}
`;
      });
    });
    this.fileService.updateFile(todoFile, data);
  }
  async getShouldExcludeFile(file) {
    var _a, _b;
    const isTodoFile = file.name == this.settings.todoFilename;
    if (isTodoFile) {
      return true;
    }
    if (this.excludeCache[file.path]) {
      return true;
    }
    let parentPath = (_b = (_a = file.parent) == null ? void 0 : _a.path) != null ? _b : "";
    if (!parentPath) {
      return false;
    }
    if (parentPath.at(0) !== "/") {
      parentPath = "/" + parentPath;
    }
    let excludeFolderFilepath = parentPath.endsWith("/") ? parentPath + this.settings.excludeFolderFilename : `${parentPath}/${this.settings.excludeFolderFilename}`;
    if (this.excludeCache[parentPath] != null) {
      return this.excludeCache[parentPath];
    }
    excludeFolderFilepath = excludeFolderFilepath.replace("//", "/");
    let isFolderExcluded = await this.fileService.checkExists(excludeFolderFilepath);
    if (!isFolderExcluded && file.parent) {
      isFolderExcluded = await this.getShouldExcludeFile(file.parent);
    }
    if (parentPath) {
      this.excludeCache[parentPath] = isFolderExcluded;
    }
    return isFolderExcluded;
  }
};
var todoService_default = TodoService;

// main.ts
var ExtendedTaskListsPlugin = class extends import_obsidian2.Plugin {
  constructor() {
    super(...arguments);
    this.updateTodo = async () => {
      const vault = this.app.vault;
      const fileService = new VaultFileService(vault);
      const service = new todoService_default(fileService, this.settings);
      const todoFiles = await service.findTodosFiles();
      const todos = todoFiles.map((todoFile2) => {
        const todos2 = service.parseTodos(todoFile2.contents);
        todos2.forEach((todo) => todo.file = todoFile2.file);
        return todos2;
      }).reduce((prev, cur) => prev.concat(cur), []);
      const todoFile = await this.getOrCreateTodoFile(vault);
      await service.saveTodos(todoFile, todos);
    };
    this.getOrCreateTodoFile = async (vault) => {
      let todoFile;
      try {
        todoFile = await vault.create(this.settings.todoFilename, "");
      } catch (e) {
        const todoFileOrNull = vault.getAbstractFileByPath(this.settings.todoFilename);
        if (todoFileOrNull == null) {
          throw new Error(`Could not get or create the TODO file: ${this.settings.todoFilename}`);
        } else if (!(todoFileOrNull instanceof import_obsidian2.TFile)) {
          throw new Error(`The retrieved TODO file is a folder: ${this.settings.todoFilename}`);
        }
        todoFile = todoFileOrNull;
      }
      return todoFile;
    };
  }
  async onload() {
    await this.loadSettings();
    this.addCommand({
      id: "update-todo",
      name: "Update TODO",
      callback: this.updateTodo
    });
    this.addSettingTab(new ExtendedTaskListsSettingTab(this.app, this));
    this.registerMarkdownPostProcessor((element, context) => {
      const taskItems = element.findAll(".task-list-item");
      for (const taskItem of taskItems) {
        const char = taskItem.dataset.task;
        const checkbox = taskItem.find("input[type='checkbox']");
        switch (char) {
          case ".":
            checkbox.indeterminate = true;
            registerIndeterminateClick(checkbox);
            break;
          case "~":
            checkbox.classList.add("wont-do");
            taskItem.classList.add("wont-do");
            registerWontDoClick(checkbox, taskItem);
            break;
        }
      }
    });
    const registerIndeterminateClick = (checkbox) => {
      let handled = false;
      this.registerDomEvent(checkbox, "click", (evt) => {
        if (handled) {
          return;
        }
        handled = true;
        checkbox.indeterminate = false;
        checkbox.checked = true;
        evt.stopPropagation();
      });
    };
    const registerWontDoClick = (checkbox, taskItem) => {
      let handled = false;
      this.registerDomEvent(checkbox, "click", (evt) => {
        if (handled) {
          return;
        }
        handled = true;
        checkbox.checked = true;
        checkbox.classList.remove("wont-do");
        taskItem.classList.remove("wont-do");
        evt.stopPropagation();
      });
    };
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
